\documentclass{report}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{indentfirst}

\geometry{a4paper,top=2cm,bottom=2cm,left=2cm,right=1.5cm}
\setlength{\parskip}{0.5cm}
\setlist{nolistsep, itemsep=0.3cm,parsep=0pt}

\lstset{language=C++,
basicstyle=\footnotesize,
keywordstyle=\color{blue}\ttfamily,
stringstyle=\color{red}\ttfamily,
commentstyle=\color{green}\ttfamily,
morecomment=[l][\color{magenta}]{\#},
tabsize=4,
breaklines=true,
breakatwhitespace=true,
title=\lstname,
}

\makeatletter
\renewcommand\@biblabel[1]{#1.\hfil}
\makeatother

\begin{document}

\begin{titlepage}

\begin{center}
Министерство науки и высшего образования Российской Федерации
\end{center}

\begin{center}
Федеральное государственное автономное образовательное учреждение высшего образования \\
Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского
\end{center}

\begin{center}
Институт информационных технологий, математики и механики
\end{center}

\vspace{4em}

\begin{center}
\textbf{\LargeОтчет по лабораторной работе} \\
\end{center}
\begin{center}
\textbf{\Large«Маркировка компонент на бинарном изображении»} \\
\end{center}

\vspace{4em}

\newbox{\lbox}
\savebox{\lbox}{\hbox{text}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{7cm}{
\hspace*{5cm}\hspace*{-5cm}\textbf{Выполнила:} \\ студентка группы 381806-2 \\ Новожилова Е.М.\\
\\
\hspace*{5cm}\hspace*{-5cm}\textbf{Проверил:}\\ доцент кафедры МОСТ, \\ кандидат технических наук \\ Сысоев А.В.\\
}
\vspace{\fill}

\begin{center} Нижний Новгород \\ 2021 \end{center}

\end{titlepage}

\setcounter{page}{2}

\tableofcontents
\newpage

\section*{Введение}
\addcontentsline{toc}{section}{Введение}
\parМаркировка компонент на изображении - алгоритм-приложение теории графов, основанное на такой обработке изображения, что каждая связная компонента отмечается уникальной меткой. При внедрении данного алгоритма в систему распознования образов он может оказаться весьма полезным. 
\parНесмотря на то, что в основном таким образом обрабатываются цветные изображения, существуют упрощённые алгоритмы маркировки и для бинарных чёрно-белых изображений, которые и будут рассмотрены в рамках этой работы.

\newpage

\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}
\parНеобходимо реализовать алгоритм маркировки связных компонент бинарного изображения и представить одну последовательную и две параллельные его версии. В качестве технологий распараллеливания будут рассмотрены стандарт OpenMP и  библиотека шаблонов C++ Intel Threading Building Blocks (TBB). Для тестирования реализаций будет использована библиотека для модульного тестирования Google testing framework (gtest).
\par Также необходимо сравнить и проанализировать эффективность всех трех версий. 

\newpage

\section*{Теоретическая часть}
\addcontentsline{toc}{section}{Теоретическая часть}
Положим, входное изображение будет кодироваться следующим образом: 0 - цвет фона (белый), 1 - цвет объектов (чёрный).
\subsection{Виды связности}
Связанная область – набор пикселей на изображении, в котором любые две пикселя соединены друг с другом через последовательность соседей.
Существуют 2 вида связности.
\begin{enumerate}
    \item \textbf{4-cвязность.}
    \par Cоседями пикселя считаются пиксели, имеющие с выбранным пикселем одну общую сторону.
    \item \textbf{8-cвязность.}
    \par Cоседями пикселя считаются пиксели, имеющие с выбранным пикселем общую сторону или общий угол.
\end{enumerate}
\par В качестве реализуемого вида связности выберем 4-связность как наиболее общую.
\subsection{Существующие алгоритмы реализации}
\parВ компьютерном зрении в основном используются 2 варианта реализации маркировки бинарного изображения:
\begin{enumerate}
    \item рекурсивный алгоритм;
    \item циклический (итеративный) алгоритм.
\end{enumerate}
\parРассмотрим каждый и выберем один для реализации в рамках лабораторной работы.
\subparagraph {Рекурсивный алгоритм.}
\par Реализуется функция, в качестве параметров которой выступают входное изображение, массив меток, который в результате будет представлен графически, координаты текущего обрабатываемого пикселя и его текущая метка. Она рекурсивно вызывается в своём теле с параметрами пикселей-соседей текущего пикселя. Если текущий пиксель - непромаркированный пиксель объекта, ему присваивается новая метка.
\par Как и любой другой рекурсивный алгоритм, этот алгоритм занимает значительный объём памяти во время своего выполнения, при этом не являясь самым быстрым вариантом реализации.
\subparagraph {Циклический (итеративный) алгоритм.}
\par Реализуется сравнение метки текущего пикселя с метками пикселей-соседей слева и сверху. Положим, текущий пиксель не помечен и является пикселем объекта. Тогда, если соседей сверху и слева нет, ему присваивается новая метка. Если  есть сосед либо слева, либо сверху, то его метка, очевидно, уже обработанная на предыдущих итерациях, присваивается и текущему пикселю. Если есть соседи и сверху, и слева, то всем трём пиксеям присваивается минимальная из двух меток соседей. Однако одного такого обхода изображения мало: для этого алгоритма нужно выполнить проверку совпадения меток соседних пикселей, и в случае, если они не совпадают, повторить алгоритм.
\par Наиболее оптимальным как по занимаемому объёму памяти, так и по времени выполнения был выбран циклический (итеративный) алгоритм.
\newpage

\section*{Практическая часть}
\addcontentsline{toc}{section}{Практическая часть}
\subsection{Реализация последовательной программы}
На вход подаётся бинарное изображение, пиксели фона у которого кодируются нулём, а пиксели черных объектов - единицей. Доступ к пикселям осуществляется через метод 
\begin{lstlisting}
at<Vec3b>(i, j),
\end{lstlisting}
где i, j - координаты пикселей.
\par Создаётся массив меток того же размера, что и изображение, создаётся переменная метки, инициализированная нулём. Далее реализуется циклический (итеративный) алгоритм маркировки, описанный выше. В результате имеем заполненный массив меток, где каждая связная компонента отмечена своим уникальным числом (своей меткой), в реализации с графическим выводом результата - своим уникальным цветом. 

\subsection{Схема распараллеливания по стандарту OpenMP}
Распараллеливание по стандарту OpenMP подразумевает под собой распараллеливание циклов программы. Переменная метки, фигурирующая в распараллеливаемых циклах, объявляется как shared. Проблема гонки за её значением решается с помощью директивы 
\begin{lstlisting}
#pragma omp critical,
\end{lstlisting}
в которую занесено инкрементирование shared метки и присваивание её текущему элементу массива меток. Данную часть кода может выполнять только один поток в произвольный момент времени.
\par Также было необходимо распараллелить двойные циклы так, чтобы 2 соседние строки и 2 соседних столбца матрицы меток не менялись одновременно, так как это бы привело к неправильному результату, учитывая, что с меткой текущего пикселя сравниваются метки из соседних строк и столбцов. Цикл из последовательной версии был разнесён на два: в одном обрабатывались нечётные строки, а в другом - чётные. 
\begin{lstlisting}
#pragma omp parallel shared(label)
    { // defining chunk in accordance to the number of threads
    ...
    ...
    #pragma omp for schedule(static, chunk)
    for (int i = 0; i < rows; i += 2) {
        for (int j = 0; j < cols; j++) {
        ...
        ...
        }
    }
    #pragma omp for schedule(static, chunk)
        for (int i = 1; i < rows; i += 2) {
            for (int j = 0; j < cols; j++) { 
            ...
            ...
            }
        }
}
\end{lstlisting}
Нетрудно заметить, что такое решение обеспечивает верный результат и отсутствие гонки за данными.
\par Обратный обход реализован с правого нижнего конца матрицы, за определение числа повторов отвечает shared rep, значение которой станет true, если не будет выполняться условие правильной маркировки: все соседи имеют одну и ту же метку.
\begin{lstlisting}
while (rep) {
        #pragma omp parallel
        {
            #pragma omp for schedule(static, chunk)
            for (int i = rows - 1; i >= 0; i -= 2) {
                for (int j = cols - 1; j >= 0; j--) {
                ...
                ...
                }
            }
        }
        ...// condition for repeat
    }
\end{lstlisting}
\subsection{Схема распараллеливания с помощью библиотеки шаблонов TBB}
В ходе работы над данной реализацией так же было продумано решение, гарантирующее отсутствие гонки за данными. Переменную метки изменяет в произвольной момент времени только поток, захвативший
\begin{lstlisting}
spin_mutex,
\end{lstlisting}
т. е. мьютекс, выполняющий активное ожидание. Поток, пытающийся захватить уже захваченный мьютекс, продолжает это делать, пока мьютекс не освободится, и только тогда переменной метки можно будет присвоить новое значение.
\begin{lstlisting}
{   ...
    tbb::spin_mutex mtx;
    tbb::spin_mutex::scoped_lock lock;
    lock.acquire(mtx);
    label++;
    lab[i][j] = label;
    lock.release();
    ...
}
\end{lstlisting}
\par Обход реализован также по нечётным и чётным строкам матрицы по отдельности, только теперь это возможно благодаря оператору if, не дающему в цикле для чётных строк обрабатываться нечётным и наоборот. Функтор был реализован с помощью лямбда-выражений.
\begin{lstlisting}
tbb::parallel_for(tbb::blocked_range<int>(0, rows, rows/4), [&](const tbb::blocked_range<int>& Range) {
        for (int i = Range.begin(); i < Range.end(); i++) {
            for (int j = 0; j < cols; j++) { 
                if ((i % 2 == 0)||(i == 0)) {
                ...
                ...
                }
            }
        }
    });
tbb::parallel_for(tbb::blocked_range<int>(1, rows, (rows-1)/4), [&](const tbb::blocked_range<int>& Range) {
        for (int i = Range.begin(); i < Range.end(); i++) {
            for (int j = 0; j < cols; j++) {
                if(i % 2 != 0) {
                ...
                ...
                }
            }
        }
    });
\end{lstlisting}
Grainsize был выбран так, что распараллеливание происходит максимально эффективно.

\subsection{Дополнительные функции для тестирования реализаций}
Была релизована функция генерации случайной матрицы
\begin{lstlisting}
std::vector<std::vector<int>> myrand(int rows, int cols, int bl_pix_quant),
\end{lstlisting}
параметры которой - число строк, столбцов и число генерируемых чёрных пикселей.
\par Для параллельных версий алгоритма были реализованы функции, проверяющие результаты на верность. Учитывая, что потоки работают практически независимо друг от друга и могут отмечать области произвольно, полного совпадения массивов меток последовательной версии и параллельных версий никогда не произойдёт.
\par Функция
\begin{lstlisting}
int check_for_par(std::vector<std::vector<int>> lab, int rows, int cols)
\end{lstlisting}
считает число связных компонент, получившихся в результате работы параллельной версии программы, и проверяет совпадение соседних меток. 
\par Функция 
\begin{lstlisting}
int check_for_seq(std::vector<std::vector<int>> lab, int rows, int cols)
\end{lstlisting}
считает число связных компонент, получившихся в результате работы параллельной версии программы (считаем последовательную версию верной ввиду тестирования на заранее известных, не полученных рандомно, матрицах).
Если число связных компонент равно и метки всех соседей совпадают, то параллельная версия реализована правильно.
\newpage

\section*{Тестирование и результаты экспериментов}
\addcontentsline{toc}{section}{Тестирование и результаты экспериментов}
Все тесты были пройдены. Программы реализованны верно.
\par Характеристики ПК, на котором проводилось тестирование:
\begin{enumerate}
    \item Процессор: Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHz   2.50 GHz
    \item Оперативная память 6 GB
    \item Операционная система Microsoft Windows 10 Home Rus x64
\end{enumerate}
\par Тесты с разными размерами изображения показывают разную эффективность. Для опререлённости выберем матрицу 500х535.
Пусть число потоков равно 4.
\begin{table}[!h]
\centering
\begin{tabular}{| r | r | r |}
\hline
Версия & Время (с) & Ускорение \\[5pt]
\hline
SEQ & 0.507220 & -     \\
OMP & 0.0903254 & 5.615 \\
TBB & 0.148415 & 3.4175 \\
\hline
\end{tabular}
\end{table}
\par Для данной задачи эффективность распараллеливания алгоритма очевидна.

\newpage
\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
В ходе лабораторной работы был изучен алгоритм маркировки бинарного изображения, была реализована последовательная версия, а также 2 паралелльные. Результаты последовательной версии были проверены на известных матрицах, а результаты паралелльных версий были сравнены с результатами последовательной версии, что гарантирует правильность выполнения лабораторной работы.
\par Алгоритм маркировки бинарного изображения - задача, эффективность которой очевидно возрастает при распараллеливании. Путём эксперимента было найдено примерное ускорение работы алгоритма в случае использования OpenMP и TBB.

\newpage
	\begin{thebibliography}{1}
		\addcontentsline{toc}{section}{Список литературы}
		\bibitem{1} "https://www.mallenom.ru/company/publications/321/"
		\bibitem{2} "https://en.wikipedia.org/wiki/Connected-componentlabeling"
		\bibitem{3} Intel(R) Threading Building Blocks Reference Manual
		\bibitem{4} Гергель В. П. - Теория и практика параллельных вычислений
	\end{thebibliography}
\end{document}